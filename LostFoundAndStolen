enum signalStates {INERT, GO, RESOLVE};  //00, 01, 10 in [A] [B]
byte signalState = INERT;

enum blinkCommss {ONE, TWO, THREE, FOUR, FIVE, SIX, WINTHREE, WINONE, NOWINNER, TOGGLEHIDESECRET, TOGGLETEAM, EXTRA, SPINNING,
TOGGLERAINBOW, RIPPLE, NULLCOMM}; //000, 001, 010, 100, 011, 101, 110, 111 in [C] [D] [E] [F]
//blinkComms has 16 distinct options
//byte blinkComms[16] = {ONE, TWO, FOUR, ONE, THREE, ONE};
//array to loop through for each face when sending comms
byte blinkComms[6];

bool hideSecret = false;
byte secretNumberIterator = 0;
//will be real # -1
byte treasureSecretsReceived[6] = {0, 0, 0, 0, 0, 0}; // reads all faces to compare secret #s
//setting to 6 means no winning face

bool amTreasure = false;
bool amTeamTreasure = false;
bool isFirstTeamTreasure = true;
Timer firstTeamTreasureTimer;
//TREASURE sparkle or TEAMCOLOR
enum treasureTypes {FullTreasure, OneToGive, NoneToGive};
byte treasureType = FullTreasure;

byte clickDim = 255;

Color teamColors[] = { RED, ORANGE, YELLOW, GREEN, BLUE, MAGENTA };
byte currentTeamColor = 0;
Color displayColor[] = {OFF,OFF,OFF,OFF,OFF,OFF};
byte teamColorTreasure;

byte winningFace = 6;
byte troubleshootFace = 6;
byte winningFaceArray[6] = {0, 0, 0, 0, 0, 0}; 
bool isWinner = false;
bool stopRefresh = false;

Timer checkWinnerTimer;
#define CHECKING_DURATION 3000
Timer sparkleTimer;
#define SPARKLE_DURATION 100
Timer simpleIterateFaceTimer;
int simpleIterateFace = 0;
Timer facetFaceRotationTimer;
int baseFacetFace=0;

bool skipSendingSecretNumber = false;

void setup(){
  
}

void loop() {
  switch (signalState) {
    case INERT:
      inertLoop();
      break;
    case GO:
      goLoop();
      break;
    case RESOLVE:
      resolveLoop();
      break;
  }

    displayFaceColor();

    FOREACH_FACE(f) {
      byte sendData = (signalState << 4) + (blinkComms[f]);
      setValueSentOnFace(sendData, f);   
    }
}

void inertLoop() {
  skipSendingSecretNumber = false;
  
  if (buttonLongPressed()) {
      //cycle team color
      currentTeamColor = (currentTeamColor + 1) % 6;
      //cycle all team colors for cluster
      FOREACH_FACE(f) {
        blinkComms[f] = TOGGLETEAM;
      }
      signalState = GO;
  }
    
  if ( buttonSingleClicked()) {
      if(!hideSecret && !amTreasure) {
        //increment clickCount 
        secretNumberIterator = (secretNumberIterator + 1) % 6;
    }

      if(amTreasure) {
        checkForWinner();
      }
  }
  

  if (buttonDoubleClicked()) {
    hideSecret = !hideSecret;
    FOREACH_FACE(f) {
      blinkComms[f] = TOGGLEHIDESECRET;
    }
    signalState = GO;
  }
  
  if (buttonMultiClicked() && buttonClickCount() == 3) {
    amTreasure = !amTreasure;
    if(amTreasure){
      amTeamTreasure = false;
    }
    else{
    }
    hideSecret = false;
  }

//both TREASURE and TEAMCOUNTER check for GO phase
    FOREACH_FACE(f) {
      if (!isValueReceivedOnFaceExpired(f)) {//we have a neighbor
        if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {
          signalState = GO;
//          resetTreasure();
       
       //Treasure Actions
          if(amTreasure) {
             if(getBlinkComms(getLastValueReceivedOnFace(f)) == ONE && getBlinkComms(getLastValueReceivedOnFace(f)) == TWO && 
             getBlinkComms(getLastValueReceivedOnFace(f)) == THREE && getBlinkComms(getLastValueReceivedOnFace(f)) == FOUR &&
             getBlinkComms(getLastValueReceivedOnFace(f)) == FIVE && getBlinkComms(getLastValueReceivedOnFace(f)) == SIX){
            }
            checkForWinner();
            //if you are isFirstTeamTreasure you aren't anymore
            isFirstTeamTreasure = false;
          }

       //Bandit actions
          else{
            //if neighbor NOT Bandit
             if(getBlinkComms(getLastValueReceivedOnFace(f)) != ONE && getBlinkComms(getLastValueReceivedOnFace(f)) != TWO && 
             getBlinkComms(getLastValueReceivedOnFace(f)) != THREE && getBlinkComms(getLastValueReceivedOnFace(f)) != FOUR &&
             getBlinkComms(getLastValueReceivedOnFace(f)) != FIVE && getBlinkComms(getLastValueReceivedOnFace(f)) != SIX &&
             getBlinkComms(getLastValueReceivedOnFace(f)) != TOGGLEHIDESECRET && getBlinkComms(getLastValueReceivedOnFace(f)) != TOGGLETEAM){
              //reveal numbers if not amTreasure (so Bandit) and neighbor is not Bandit
              hideSecret = false;
             }
            //if neighbor is Bandit
            else{
              if(getBlinkComms(getLastValueReceivedOnFace(f)) == TOGGLEHIDESECRET ){
                hideSecret = !hideSecret;
                skipSendingSecretNumber = true;
              }
              if(getBlinkComms(getLastValueReceivedOnFace(f)) == TOGGLETEAM ){
                currentTeamColor = (currentTeamColor + 1) % 6;
                skipSendingSecretNumber = true;
           
              }
            }

            //if winner then become TreasureBandit
            if(getBlinkComms(getLastValueReceivedOnFace(f)) == WINTHREE || getBlinkComms(getLastValueReceivedOnFace(f)) == WINONE){
              amTreasure = true;
              amTeamTreasure = true;
              resetTreasure();
              setDisplayColor(WHITE, WHITE, WHITE, WHITE, WHITE, WHITE);
              teamColorTreasure = f;
              displayColor[f] = teamColors[currentTeamColor];
              checkWinnerTimer.set(3000);
            }
          }
        }
      }
    }
   
    
    //only TEAMCOUNTER sets blinkComms
  if(!skipSendingSecretNumber && !amTreasure){
//  if(!amTreasure){
    FOREACH_FACE(f) {
      switch (secretNumberIterator) {
        case 0:
          blinkComms[f] = ONE;
          break;
        case 1:
          blinkComms[f] = TWO;
          break;
        case 2:
          blinkComms[f] = THREE;
          break;
        case 3:
          blinkComms[f] = FOUR;
          break;
        case 4:
          blinkComms[f] = FIVE;
          break;
        case 5:
          blinkComms[f] = SIX;
          break;
      }
    }
  }

}

void goLoop() {
    signalState = RESOLVE;//I default to this at the start of the loop. Only if I see a problem does this not happen

  if(blinkComms[0] == TOGGLETEAM){
    FOREACH_FACE(f) {
      blinkComms[f] = NULLCOMM;
    }
  }
    

  //look for neighbors who have not heard the GO news
  FOREACH_FACE(f) {
    if (!isValueReceivedOnFaceExpired(f)) {//a neighbor!
      if (getSignalState(getLastValueReceivedOnFace(f)) == INERT) {//This neighbor doesn't know it's GO time. Stay in GO
        signalState = GO;
        
      }
    }
  }
}

void resolveLoop() {
    signalState = INERT;//I default to this at the start of the loop. Only if I see a problem does this not happen

  //look for neighbors who have not moved to RESOLVE
  FOREACH_FACE(f) {
    if (!isValueReceivedOnFaceExpired(f)) {//a neighbor!
      if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {//This neighbor isn't in RESOLVE. Stay in RESOLVE
        signalState = RESOLVE;
      }
    }
  }
}


void checkForWinner(){
  checkWinnerTimer.set(3000);
  
  FOREACH_FACE(f) {
      treasureSecretsReceived[f] = 0;
    if (!isValueReceivedOnFaceExpired(f) ){//a neighbor
  
//      if(getRole(getLastValueReceivedOnFace(f)) == TEAMCOUNTER) {  //a Counter neighbor!
         byte newNumberText = getBlinkComms(getLastValueReceivedOnFace(f));
          switch (newNumberText) {
            case ONE:
              treasureSecretsReceived[f] = 1;
              break;
            case TWO:
              treasureSecretsReceived[f] = 2;
              break;
            case THREE:
              treasureSecretsReceived[f] = 3;
              break;
            case FOUR:
              treasureSecretsReceived[f] = 4;
              break;
            case FIVE:
              treasureSecretsReceived[f] = 5;
              break;
            case SIX:
              treasureSecretsReceived[f] = 6;
              break;
          }
          //if NOT Bandit
           if(getBlinkComms(getLastValueReceivedOnFace(f)) != ONE && getBlinkComms(getLastValueReceivedOnFace(f)) != TWO && 
           getBlinkComms(getLastValueReceivedOnFace(f)) != THREE && getBlinkComms(getLastValueReceivedOnFace(f)) != FOUR &&
           getBlinkComms(getLastValueReceivedOnFace(f)) != FIVE && getBlinkComms(getLastValueReceivedOnFace(f)) != SIX){
              treasureSecretsReceived[f] = 0;
           }
       }
  }

        displayColor[0] = CYAN;
        displayColor[1] = WHITE;
        displayColor[2] = CYAN;
        displayColor[3] = WHITE;
        displayColor[4] = CYAN;
        displayColor[5] = WHITE;

  if(treasureSecretsReceived[0] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[5]) {
    setDisplayColor(WHITE, YELLOW, OFF, OFF, OFF, YELLOW);
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure){
      blinkComms[0] = WINONE;
    }
  }
  else if(treasureSecretsReceived[1] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[5]) {
    displayColor[0] = YELLOW;
    displayColor[1] = WHITE;
    displayColor[2] = YELLOW;
    displayColor[3] = OFF;
    displayColor[4] = OFF;
    displayColor[5] = OFF;
    if(amTreasure){
      blinkComms[1] = WINTHREE;
    }
    else if(amTeamTreasure){
      blinkComms[1] = WINONE;
    }
  }
  else if(treasureSecretsReceived[2] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[5]) {
    displayColor[0] = OFF;
    displayColor[1] = YELLOW;
    displayColor[2] = WHITE;
    displayColor[3] = YELLOW;
    displayColor[4] = OFF;
    displayColor[5] = OFF;
    if(amTreasure){
      blinkComms[2] = WINTHREE;
    }
    else if(amTeamTreasure){
      blinkComms[2] = WINONE;
    }
  }
  else if(treasureSecretsReceived[3] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[5]) {
    displayColor[0] = OFF;
    displayColor[1] = OFF;
    displayColor[2] = YELLOW;
    displayColor[3] = WHITE;
    displayColor[4] = YELLOW;
    displayColor[5] = OFF;
    if(amTreasure){
      blinkComms[3] = WINTHREE;
    }
    else if(amTeamTreasure){
      blinkComms[3] = WINONE;
    }
  }
  else if(treasureSecretsReceived[4] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[5]) {
    displayColor[0] = OFF;
    displayColor[1] = OFF;
    displayColor[2] = OFF;
    displayColor[3] = YELLOW;
    displayColor[4] = WHITE;
    displayColor[5] = YELLOW;
    if(amTreasure){
      blinkComms[4] = WINTHREE;
    }
    else if(amTeamTreasure){
      blinkComms[4] = WINONE;
    }
  }
  else if(treasureSecretsReceived[5] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[4]) {
    displayColor[0] = YELLOW;
    displayColor[1] = OFF;
    displayColor[2] = OFF;
    displayColor[3] = OFF;
    displayColor[4] = YELLOW;
    displayColor[5] = WHITE;        
    if(amTreasure){
      blinkComms[5] = WINTHREE;
    }
    else if(amTeamTreasure){
      blinkComms[5] = WINONE;
    }
  }

  
  signalState = GO;
  stopRefresh = false;
}


byte setDisplayColor(Color f0, Color f1, Color f2, Color f3, Color f4, Color f5){
    displayColor[0] = f0;
    displayColor[1] = f1;
    displayColor[2] = f2;
    displayColor[3] = f3;
    displayColor[4] = f4;
    displayColor[5] = f5;
}

byte fullSparkle(Color white, Color blue){
  if( facetFaceRotationTimer.isExpired() ){
    facetFaceRotationTimer.set(100);
    baseFacetFace ++;
  }
  int whiteShine = random(5);
  int whiteShine2 = random(5)-3;
  int whiteShine3 = random(2);
  int blueShine = random(2);
  int purpShine = random(5);
  Color blue2 = makeColorRGB(84,204,255);
  Color purp = makeColorRGB(134,125,255);
  
    displayColor[baseFacetFace] = blue2;
    displayColor[baseFacetFace+1] = purp;
    displayColor[baseFacetFace+2] = blue2;
    displayColor[baseFacetFace+3] = purp;
    displayColor[baseFacetFace+4] = blue2;
    displayColor[baseFacetFace+5] = purp;
    displayColor[purpShine] = purp;    
    displayColor[whiteShine] = white;
    displayColor[blueShine] = blue;
    displayColor[(blueShine+2)%6] = blue;
    displayColor[whiteShine2] = white;
    displayColor[whiteShine3] = white;
}

void resetTreasure(){
  blinkComms[0] = NULLCOMM;
  blinkComms[1] = NULLCOMM;
  blinkComms[2] = NULLCOMM; 
  blinkComms[3] = NULLCOMM;
  blinkComms[4] = NULLCOMM; 
  blinkComms[5] = NULLCOMM; 
//  needToSendWinSignal = false;
//  winningFace = 7;
}



void displayFaceColor() {
  //default OFF to stop color lingering
  setColor(OFF);
    
  switch (signalState) {
    case INERT:
      FOREACH_FACE(f) {
        if (!amTreasure && f <= secretNumberIterator){
          setColorOnFace(dim(teamColors[currentTeamColor],clickDim),f);
        }
        else if ( amTreasure ) {
          if( sparkleTimer.isExpired() ){
            sparkleTimer.set(10);
            fullSparkle(WHITE, CYAN);
          }
//          if(amTeamTreasure) {
//            setColorOnFace(teamColors[currentTeamColor],teamColorTreasure);  
//          }

          setColorOnFace(displayColor[f],f);
         
        }
               
      }

      //checking winner or delaying winner reveal
      if(!checkWinnerTimer.isExpired()){
        if(amTreasure && !amTeamTreasure){
          setColorOnFace(dim(WHITE,150),simpleIterateFace % 6);
          setColorOnFace(WHITE,(simpleIterateFace+1) % 6);
          setColorOnFace(dim(WHITE,150),(simpleIterateFace+2) % 6);
          setColorOnFace(OFF,(simpleIterateFace+3) % 6);
          setColorOnFace(OFF,(simpleIterateFace+4) % 6);
          setColorOnFace(OFF,(simpleIterateFace+5) % 6);
          if( simpleIterateFaceTimer.isExpired() ){
            simpleIterateFaceTimer.set(500);
            simpleIterateFace ++;
          }
        }

        if(amTeamTreasure && isFirstTeamTreasure){
//          isFirstTeamTreasure = false;
          FOREACH_FACE(f) {
            setColorOnFace(OFF, f);
            if(f <= secretNumberIterator){
              setColorOnFace(dim(teamColors[currentTeamColor],clickDim),f);
            }
          }
        }
      }
      
      if(amTeamTreasure && checkWinnerTimer.isExpired()){
        FOREACH_FACE(f) {
          setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
          setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 1) % 6);
          setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 5) % 6);
//          setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
//          setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
//          setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
                    
//          displayColor[f] = teamColors[currentTeamColor];
        }
      }
      
      if (!amTreasure && hideSecret) {
        //make all faces your team color
        setColor(dim(teamColors[currentTeamColor],clickDim));
        setColorOnFace(OFF,simpleIterateFace % 6);
        setColorOnFace(OFF,(simpleIterateFace+3) % 6);
        if( simpleIterateFaceTimer.isExpired() ){
          simpleIterateFaceTimer.set(50);
          simpleIterateFace ++;
        }
      }


      
      break;
    case GO:
      setColor(MAGENTA);
      break;
    case RESOLVE:
      setColor(WHITE);
      break;
  }
}


byte getSignalState(byte data) {
    return ((data >> 4) & 3);//returns bits A & B
}

byte getBlinkComms(byte data) {
    return (data & 15);//returns bits C , D & E
}

