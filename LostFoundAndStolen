enum signalStates {INERT, GO, RESOLVE};  //00, 01, 10 in [A] [B]
byte signalState = INERT;

enum blinkCommss {ONE, TWO, THREE, FOUR, FIVE, SIX, WINTHREE, WINONE, NOWINNER, TOGGLEHIDESECRET, TOGGLETEAM, EXTRA, SPINNING,
TOGGLERAINBOW, RIPPLE, NULLCOMM}; //000, 001, 010, 100, 011, 101, 110, 111 in [C] [D] [E] [F]
//blinkComms has 16 distinct options
//byte blinkComms[16] = {ONE, TWO, FOUR, ONE, THREE, ONE};
//array to loop through for each face when sending comms
byte blinkComms[6] = {TWO, NULLCOMM, NULLCOMM, NULLCOMM, NULLCOMM, NULLCOMM};
bool twoAvail = true;
bool fourAvail = true;
bool sixAvail = true;
byte numberToSend = 0;
bool hideSecret = false;
byte secretNumberIterator = 1;
//will be real # -1
byte treasureSecretsReceived[6] = {0, 0, 0, 0, 0, 0}; // reads all faces to compare secret #s
//setting to 6 means no winning face

//bool amTreasure = false;
//bool amTeamTreasure1 = false;
//bool amTeamTreasure2 = false;
//bool amTeamTreasure3 = false;
bool isFirstTeamTreasure = false;
bool waitingAfterLoss = false;
//Timer firstTeamTreasureTimer;
//TREASURE sparkle or TEAMCOLOR
enum treasureTypes {NotTreasure, FullTreasure, TeamTreasure3, TeamTreasure2, TeamTreasure1};
byte treasureType = NotTreasure;
bool canGiveTreasure = true;

byte clickDim = 255;

Color teamColors[] = { RED, ORANGE, YELLOW, GREEN, BLUE, MAGENTA };
byte currentTeamColor = 0;
Color displayColor[] = {OFF,OFF,OFF,OFF,OFF,OFF};
byte teamColorTreasure;

byte winningFace = 6;
byte winningFaceArray[6] = {0, 0, 0, 0, 0, 0}; 

Timer checkWinnerTimer;
#define CHECKING_DURATION 3000
Timer sparkleTimer;
#define SPARKLE_DURATION 100
Timer checkingFaceTimer;
int checkingFace = 0;
//Timer simpleIterateFaceTimer;
//int simpleIterateFace = 0;
Timer simpleIterateFaceTimer;
int simpleIterateFace = 0;
Timer facetFaceRotationTimer;
int baseFacetFace=0;
Timer blinkFace0Timer;

bool skipSendingSecretNumber = false;

void setup(){
  
}

void loop() {
  switch (signalState) {
    case INERT:
      inertLoop();
      break;
    case GO:
      goLoop();
      break;
    case RESOLVE:
      resolveLoop();
      break;
  }

    displayFaceColor();

    FOREACH_FACE(f) {
      byte sendData = (signalState << 4) + (blinkComms[f]);
      setValueSentOnFace(sendData, f);   
    }
}

void inertLoop() {
      //BANDIT
  if(treasureType == NotTreasure){
//  if(!amTreasure && !amTeamTreasure1 && !amTeamTreasure2 && !amTeamTreasure3){    
    skipSendingSecretNumber = false;
    if(waitingAfterLoss && checkWinnerTimer.isExpired()){
      waitingAfterLoss = false;
      secretNumberIterator = 0;
    }
    
    if (buttonLongPressed()) {
        //cycle team color
        currentTeamColor = (currentTeamColor + 1) % 6;
        //cycle all team colors for cluster
        FOREACH_FACE(f) {
          blinkComms[f] = TOGGLETEAM;
        }
        signalState = GO;
        skipSendingSecretNumber = true;
    }
      
    if ( buttonSingleClicked() && !hideSecret) {
      if(twoAvail && fourAvail && sixAvail) {
        //increment clickCount 
        secretNumberIterator = (secretNumberIterator + 2) % 6;
      }
      else if(fourAvail && twoAvail){
        switch (secretNumberIterator) {
          case 0:
  //          blinkComms[f] = TWO;
            secretNumberIterator = 1;
            break;
          case 1:
  //          blinkComms[f] = FOUR;
            secretNumberIterator = 3;
            break;
          case 3:
  //          blinkComms[f] = TWO;
            secretNumberIterator = 1;
            break;
        }
      }
      else if(fourAvail && sixAvail){
        switch (secretNumberIterator) {
          case 0:
            secretNumberIterator = 3;
            break;
          case 3:
            secretNumberIterator = 5;
            break;
          case 5:
            secretNumberIterator = 3;
            break;
        }
      }
      else if(twoAvail && sixAvail){
        switch (secretNumberIterator) {
          case 0:
            secretNumberIterator = 1;
            break;
          case 1:
            secretNumberIterator = 5;
            break;
          case 5:
            secretNumberIterator = 1;
            break;
        }
      }
      else if(twoAvail){
        if(secretNumberIterator == 0) {
            secretNumberIterator = 1;
        }
      }
      else if(fourAvail){
        if(secretNumberIterator == 0) {
            secretNumberIterator = 3;
        }
      }
      else if(sixAvail){
        if(secretNumberIterator == 0) {
            secretNumberIterator = 5;
        }
      }      
    }

    if (buttonDoubleClicked()) {
      hideSecret = !hideSecret;
      FOREACH_FACE(f) {
        blinkComms[f] = TOGGLEHIDESECRET;
      }
      signalState = GO;
      skipSendingSecretNumber = true;
    }
    
    if (buttonMultiClicked() && buttonClickCount() == 3 && isAlone()) {
//    if (buttonMultiClicked()) {   
//      if (buttonClickCount() == 3) {
//        amTreasure = true;
        treasureType = FullTreasure;
//        amTeamTreasure1 = false;
//        amTeamTreasure2 = false;
//        amTeamTreasure3 = false;
        isFirstTeamTreasure = false;
//      }
    }


    FOREACH_FACE(f) {
      if (!isValueReceivedOnFaceExpired(f)) {//we have a neighbor
        if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {
          signalState = GO;

          if(getBlinkComms(getLastValueReceivedOnFace(f)) == TOGGLEHIDESECRET ){
            hideSecret = !hideSecret;
            skipSendingSecretNumber = true;
            FOREACH_FACE(f) {
              blinkComms[f] = TOGGLEHIDESECRET;
            }
          }
          if(getBlinkComms(getLastValueReceivedOnFace(f)) == TOGGLETEAM ){
            currentTeamColor = (currentTeamColor + 1) % 6;
            skipSendingSecretNumber = true;
            FOREACH_FACE(f) {
              blinkComms[f] = TOGGLETEAM;
            }
          }

          if(getBlinkComms(getLastValueReceivedOnFace(f)) == WINTHREE){
            isFirstTeamTreasure = true;
            checkWinnerTimer.set(CHECKING_DURATION);
            treasureType = TeamTreasure3;
            teamColorTreasure = f;
            hideSecret = false;
          }
          if(getBlinkComms(getLastValueReceivedOnFace(f)) == WINONE){
            isFirstTeamTreasure = true;
            checkWinnerTimer.set(CHECKING_DURATION);
            treasureType = TeamTreasure1;
            teamColorTreasure = f;
            hideSecret = false;
            canGiveTreasure = false;
          }

          if(getBlinkComms(getLastValueReceivedOnFace(f)) == NOWINNER){
            hideSecret = false;
            switch (blinkComms[0]) {
              case TWO:
                twoAvail = false;
                break;
              case FOUR:
                fourAvail = false;
                break;
              case SIX:
                sixAvail = false;
                break;
            }
            waitingAfterLoss = true;
            checkWinnerTimer.set(CHECKING_DURATION);
          }
        }
      }
    }


    if(!skipSendingSecretNumber){
//      FOREACH_FACE(f) {
        switch (secretNumberIterator) {
          case 0:
            blinkComms[0] = ONE;
            break;
          case 1:
            blinkComms[0] = TWO;
            break;
          case 3:
            blinkComms[0] = FOUR;
            break;
          case 5:
            blinkComms[0] = SIX;
            break;
        }
//      }
    }
  }

  //TREASURE
  else {
    if(isFirstTeamTreasure && checkWinnerTimer.isExpired()){
      isFirstTeamTreasure = false;
    }
        
    if ( buttonSingleClicked()) {
      checkWinnerTimer.set(CHECKING_DURATION);
      checkForWinner();
    }
    
    if (buttonMultiClicked() && buttonClickCount() == 3) {
      treasureType = NotTreasure;
      hideSecret = false;
      twoAvail = true;
      fourAvail = true;
      sixAvail = true;
      isFirstTeamTreasure = true;
      secretNumberIterator = 1;
    }
  
//check for GO phase
    FOREACH_FACE(f) {
      if (!isValueReceivedOnFaceExpired(f)) {//we have a neighbor
        if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {
          signalState = GO;
  
          if(getBlinkComms(getLastValueReceivedOnFace(f)) == NOWINNER || getBlinkComms(getLastValueReceivedOnFace(f)) == NULLCOMM){
            checkWinnerTimer.set(CHECKING_DURATION);
            checkForWinner();
          }
        }
      }
    }
  }
}

void goLoop() {
    signalState = RESOLVE;//I default to this at the start of the loop. Only if I see a problem does this not happen  

//  look for neighbors who have not heard the GO news
  FOREACH_FACE(f) {
    if (!isValueReceivedOnFaceExpired(f)) {//a neighbor!
      if (getSignalState(getLastValueReceivedOnFace(f)) == INERT) {//This neighbor doesn't know it's GO time. Stay in GO
        signalState = GO;
      }
    }
  }
}

void resolveLoop() {
    signalState = INERT;//I default to this at the start of the loop. Only if I see a problem does this not happen

  //look for neighbors who have not moved to RESOLVE
  FOREACH_FACE(f) {
    if (!isValueReceivedOnFaceExpired(f)) {//a neighbor!
      if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {//This neighbor isn't in RESOLVE. Stay in RESOLVE
        signalState = RESOLVE; 
      }
    }
  }
}


void checkForWinner(){

//  if(canGiveTreasure){
  //get numbers sent    
    FOREACH_FACE(f) {
//      if(treasureType == TeamTreasure3){
//        blinkComms[f] = NULLCOMM;
//      }
//      if(treasureType == FullTreasure){
//        blinkComms[f] = NOWINNER;
//      }
      blinkComms[f] = NOWINNER;
      treasureSecretsReceived[f] = 0;
      if (!isValueReceivedOnFaceExpired(f) ){//a neighbor
        byte newNumberText = getBlinkComms(getLastValueReceivedOnFace(f));
        switch (newNumberText) {
//          case ONE:
//            treasureSecretsReceived[f] = 1;
//            break;
          case TWO:
            treasureSecretsReceived[f] = 2;
            break;
          case THREE:
            treasureSecretsReceived[f] = 3;
            break;
          case FOUR:
            treasureSecretsReceived[f] = 4;
            break;
          case FIVE:
            treasureSecretsReceived[f] = 5;
            break;
          case SIX:
            treasureSecretsReceived[f] = 6;
            break;
        }
      }
    }
  
  //Calculate if Winner
    if(treasureSecretsReceived[0] > treasureSecretsReceived[1] && 
    treasureSecretsReceived[0] > treasureSecretsReceived[2] && 
    treasureSecretsReceived[0] > treasureSecretsReceived[3] && 
    treasureSecretsReceived[0] > treasureSecretsReceived[4] && 
    treasureSecretsReceived[0] > treasureSecretsReceived[5]) {
      setDisplayColor(WHITE, YELLOW, OFF, OFF, OFF, YELLOW);
      if(treasureType == FullTreasure){
        blinkComms[0] = WINTHREE;
      }
      else if(treasureType == TeamTreasure3){
        blinkComms[0] = WINONE;
        treasureType = TeamTreasure2;
//        canGiveTreasure = false;
      }
      else if(treasureType == TeamTreasure2){
        blinkComms[0] = WINONE;
        treasureType = TeamTreasure1;
      }
    }
    else if(treasureSecretsReceived[1] > treasureSecretsReceived[0] && 
    treasureSecretsReceived[1] > treasureSecretsReceived[2] && 
    treasureSecretsReceived[1] > treasureSecretsReceived[3] && 
    treasureSecretsReceived[1] > treasureSecretsReceived[4] && 
    treasureSecretsReceived[1] > treasureSecretsReceived[5]) {
      setDisplayColor(YELLOW, WHITE, YELLOW, OFF, OFF, OFF);
      if(treasureType == FullTreasure){
        blinkComms[1] = WINTHREE;
      }
      else if(treasureType == TeamTreasure3){
        blinkComms[1] = WINONE;
        treasureType = TeamTreasure2;
//        canGiveTreasure = false;
      }
      else if(treasureType == TeamTreasure2){
        blinkComms[1] = WINONE;
        treasureType = TeamTreasure1;
      }
    }
    else if(treasureSecretsReceived[2] > treasureSecretsReceived[0] && 
    treasureSecretsReceived[2] > treasureSecretsReceived[1] && 
    treasureSecretsReceived[2] > treasureSecretsReceived[3] && 
    treasureSecretsReceived[2] > treasureSecretsReceived[4] && 
    treasureSecretsReceived[2] > treasureSecretsReceived[5]) {
      setDisplayColor(OFF, YELLOW, WHITE, YELLOW, OFF, OFF);
      if(treasureType == FullTreasure){
        blinkComms[2] = WINTHREE;
      }
      else if(treasureType == TeamTreasure3){
        blinkComms[2] = WINONE;
        treasureType = TeamTreasure2;
//        canGiveTreasure = false;
      }
      else if(treasureType == TeamTreasure2){
        blinkComms[2] = WINONE;
        treasureType = TeamTreasure1;
      }
    }
    else if(treasureSecretsReceived[3] > treasureSecretsReceived[0] && 
    treasureSecretsReceived[3] > treasureSecretsReceived[1] && 
    treasureSecretsReceived[3] > treasureSecretsReceived[2] && 
    treasureSecretsReceived[3] > treasureSecretsReceived[4] && 
    treasureSecretsReceived[3] > treasureSecretsReceived[5]) {
      setDisplayColor(OFF, OFF, YELLOW, WHITE, YELLOW, OFF);
      if(treasureType == FullTreasure){
        blinkComms[3] = WINTHREE;
      }
      else if(treasureType == TeamTreasure3){
        blinkComms[3] = WINONE;
        treasureType = TeamTreasure2;
//        canGiveTreasure = false;
      }
      else if(treasureType == TeamTreasure2){
        blinkComms[3] = WINONE;
        treasureType = TeamTreasure1;
      }
    }
    else if(treasureSecretsReceived[4] > treasureSecretsReceived[0] && 
    treasureSecretsReceived[4] > treasureSecretsReceived[1] && 
    treasureSecretsReceived[4] > treasureSecretsReceived[2] && 
    treasureSecretsReceived[4] > treasureSecretsReceived[3] && 
    treasureSecretsReceived[4] > treasureSecretsReceived[5]) {
      setDisplayColor(OFF, OFF, OFF, YELLOW, WHITE, YELLOW);
      if(treasureType == FullTreasure){
        blinkComms[4] = WINTHREE;
      }
      else if(treasureType == TeamTreasure3){
        blinkComms[4] = WINONE;
        treasureType = TeamTreasure2;
//        canGiveTreasure = false;
      }
      else if(treasureType == TeamTreasure2){
        blinkComms[4] = WINONE;
        treasureType = TeamTreasure1;
      }
    }
    else if(treasureSecretsReceived[5] > treasureSecretsReceived[0] && 
    treasureSecretsReceived[5] > treasureSecretsReceived[1] && 
    treasureSecretsReceived[5] > treasureSecretsReceived[2] && 
    treasureSecretsReceived[5] > treasureSecretsReceived[3] && 
    treasureSecretsReceived[5] > treasureSecretsReceived[4]) {
      setDisplayColor(YELLOW, OFF, OFF, OFF, YELLOW, WHITE);
      if(treasureType == FullTreasure){
        blinkComms[5] = WINTHREE;
      }
      else if(treasureType == TeamTreasure3){
        blinkComms[5] = WINONE;
        treasureType = TeamTreasure2;
//        canGiveTreasure = false;
      }
      else if(treasureType == TeamTreasure2){
        blinkComms[5] = WINONE;
        treasureType = TeamTreasure1;
      }
    }
//  }
  signalState = GO;
}


byte setDisplayColor(Color f0, Color f1, Color f2, Color f3, Color f4, Color f5){
    displayColor[0] = f0;
    displayColor[1] = f1;
    displayColor[2] = f2;
    displayColor[3] = f3;
    displayColor[4] = f4;
    displayColor[5] = f5;
}

//byte fullSparkle(Color white, Color blue){
void fullSparkle(){
//  if( facetFaceRotationTimer.isExpired() ){
//    facetFaceRotationTimer.set(100);
//    baseFacetFace ++;
//  }
  int whiteShine = random(5);
//  int whiteShine2 = random(5)-3;
//  int whiteShine3 = random(2);
//  int blueShine = random(2);
//  int purpShine = random(5);
  Color blue2 = makeColorRGB(84,204,255);
  Color purp = makeColorRGB(134,125,255);
  
  displayColor[baseFacetFace] = blue2;
  displayColor[baseFacetFace+1] = purp;
  displayColor[baseFacetFace+2] = blue2;
  displayColor[baseFacetFace+3] = purp;
  displayColor[baseFacetFace+4] = blue2;
  displayColor[baseFacetFace+5] = purp;
//  displayColor[purpShine] = purp;    
  displayColor[whiteShine] = WHITE;
//  displayColor[blueShine] = blue;
//  displayColor[(blueShine+2)%6] = blue;
//  displayColor[whiteShine2] = WHITE;
//  displayColor[whiteShine3] = WHITE;
}


void displayFaceColor() {
  //default OFF to stop color lingering
  setColor(OFF);
    
  switch (signalState) {
    case INERT:

        //timer off
        if (checkWinnerTimer.isExpired()){
          //some type of Treasure
          if ( treasureType == FullTreasure ) {
            if( sparkleTimer.isExpired() ){
              sparkleTimer.set(10);
              fullSparkle();
              FOREACH_FACE(f) {
                setColorOnFace(displayColor[f],f);
              }
            }
          }
            //checking timer not running and Team Treasure so cover up sparkle with OFFs
          else if(treasureType == TeamTreasure3){
              if( sparkleTimer.isExpired() ){
                sparkleTimer.set(10);
                fullSparkle();
              }
              FOREACH_FACE(f) {
                setColorOnFace(displayColor[f],f);
              }              
              setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
              setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 1) % 6);
              setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 5) % 6);
          }
          else if(treasureType == TeamTreasure2){
            if( sparkleTimer.isExpired() ){
              sparkleTimer.set(10);
              fullSparkle();
            }
            FOREACH_FACE(f) {
              setColorOnFace(displayColor[f],f);
            }
            setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 1) % 6);
            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 5) % 6);
            
            setColorOnFace(OFF,(teamColorTreasure + 3) % 6);
          }
          else if(treasureType == TeamTreasure1){
            if( sparkleTimer.isExpired() ){
              sparkleTimer.set(10);
              fullSparkle();
            }
            FOREACH_FACE(f) {
              setColorOnFace(displayColor[f],f);
            }
            setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 1) % 6);
            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 5) % 6);
            
            setColorOnFace(OFF,(teamColorTreasure + 2) % 6);
            setColorOnFace(OFF,(teamColorTreasure + 4) % 6);            
          }
          //is Bandit
        else{
          FOREACH_FACE(f) {
            if( f <= secretNumberIterator){
              setColorOnFace(dim(teamColors[currentTeamColor],clickDim),f);
            }
          }
          if( blinkFace0Timer.isExpired() ){
            blinkFace0Timer.set(250);
            setColorOnFace(WHITE,0);          
          }
        }
      }


      
      //timer going
        else if (!checkWinnerTimer.isExpired()){
          if(isFirstTeamTreasure){
            FOREACH_FACE(f) {         
              //running timer and its my first time then act like a Bandit
              if( f <= secretNumberIterator){
                setColorOnFace(dim(teamColors[currentTeamColor],clickDim),f);
              }
            }
          }
          else if(treasureType == FullTreasure || treasureType == TeamTreasure1 || treasureType == TeamTreasure2 || treasureType == TeamTreasure3){
            //running timer and not my first time as Treasure or TeamTreasure so circle spin animation
            setColorOnFace(dim(WHITE,150),checkingFace % 6);
            setColorOnFace(WHITE,(checkingFace+1) % 6);
            setColorOnFace(dim(WHITE,150),(checkingFace+2) % 6);
            setColorOnFace(OFF,(checkingFace+3) % 6);
            setColorOnFace(OFF,(checkingFace+4) % 6);
            setColorOnFace(OFF,(checkingFace+5) % 6);
            if( checkingFaceTimer.isExpired() ){
              checkingFaceTimer.set(500);
              checkingFace ++;
            }          
          }
          else {
            //running timer as Bandit so just show secret number
            FOREACH_FACE(f) { 
              if( f <= secretNumberIterator){
                setColorOnFace(teamColors[currentTeamColor],f);
              }      
            }
          }
        }


      if (hideSecret) {
        setColor(dim(teamColors[currentTeamColor],clickDim));
        setColorOnFace(OFF,simpleIterateFace % 6);
        setColorOnFace(OFF,(simpleIterateFace+3) % 6);
        if( simpleIterateFaceTimer.isExpired() ){
          simpleIterateFaceTimer.set(50);
          simpleIterateFace ++;
        }
      }
                    
      break;
    case GO:
      setColor(MAGENTA);
      break;
    case RESOLVE:
      setColor(WHITE);
      break;
  }
}


byte getSignalState(byte data) {
    return ((data >> 4) & 3);//returns bits A & B
}

byte getBlinkComms(byte data) {
    return (data & 15);//returns bits C , D & E
}
