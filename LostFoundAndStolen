enum signalStates {INERT, GO, RESOLVE};  //00, 01, 10 in [A] [B]
byte signalState = INERT;

enum blinkCommss {ONE, TWO, THREE, FOUR, FIVE, SIX, WINTHREE, WINONE, NOWINNER, TOGGLEHIDESECRET, TOGGLETEAM, EXTRA, SPINNING,
TOGGLERAINBOW, RIPPLE, NULLCOMM}; //000, 001, 010, 100, 011, 101, 110, 111 in [C] [D] [E] [F]
//blinkComms has 16 distinct options
//byte blinkComms[16] = {ONE, TWO, FOUR, ONE, THREE, ONE};
//array to loop through for each face when sending comms
byte blinkComms[6];
bool twoAvail = true;
bool fourAvail = true;
bool sixAvail = true;
byte numberToSend = 0;
bool hideSecret = false;
byte secretNumberIterator = 1;
//will be real # -1
byte treasureSecretsReceived[6] = {0, 0, 0, 0, 0, 0}; // reads all faces to compare secret #s
//setting to 6 means no winning face

bool amTreasure = false;
bool amTeamTreasure1 = false;
bool amTeamTreasure2 = false;
bool amTeamTreasure3 = false;
bool isFirstTeamTreasure = true;
bool waitingAfterLoss = false;
//Timer firstTeamTreasureTimer;
//TREASURE sparkle or TEAMCOLOR
//enum treasureTypes {FullTreasure, OneToGive, NoneToGive};
//byte treasureType = FullTreasure;

byte clickDim = 255;

Color teamColors[] = { RED, ORANGE, YELLOW, GREEN, BLUE, MAGENTA };
byte currentTeamColor = 0;
Color displayColor[] = {OFF,OFF,OFF,OFF,OFF,OFF};
byte teamColorTreasure;

byte winningFace = 6;
byte winningFaceArray[6] = {0, 0, 0, 0, 0, 0}; 

Timer checkWinnerTimer;
#define CHECKING_DURATION 3000
Timer sparkleTimer;
#define SPARKLE_DURATION 100
Timer simpleIterateFaceTimer;
int simpleIterateFace = 0;
Timer facetFaceRotationTimer;
int baseFacetFace=0;

bool skipSendingSecretNumber = false;

void setup(){
  
}

void loop() {
  switch (signalState) {
    case INERT:
      inertLoop();
      break;
    case GO:
      goLoop();
      break;
    case RESOLVE:
      resolveLoop();
      break;
  }

    displayFaceColor();

    FOREACH_FACE(f) {
      byte sendData = (signalState << 4) + (blinkComms[f]);
      setValueSentOnFace(sendData, f);   
    }
}

void inertLoop() {
      //BANDIT
  if(!amTreasure && !amTeamTreasure1 && !amTeamTreasure2 && !amTeamTreasure3){
    skipSendingSecretNumber = false;
    if(waitingAfterLoss && checkWinnerTimer.isExpired()){
      waitingAfterLoss = false;
      secretNumberIterator = 0;
    }
    
    if (buttonLongPressed()) {
        //cycle team color
        currentTeamColor = (currentTeamColor + 1) % 6;
        //cycle all team colors for cluster
        FOREACH_FACE(f) {
          blinkComms[f] = TOGGLETEAM;
        }
        signalState = GO;
        skipSendingSecretNumber = true;
    }
      
    if ( buttonSingleClicked()) {
      if(twoAvail && fourAvail && sixAvail) {
        //increment clickCount 
        secretNumberIterator = (secretNumberIterator + 2) % 6;
      }
      else if(fourAvail && twoAvail){
        switch (secretNumberIterator) {
          case 0:
  //          blinkComms[f] = TWO;
            secretNumberIterator = 1;
            break;
          case 1:
  //          blinkComms[f] = FOUR;
            secretNumberIterator = 3;
            break;
          case 3:
  //          blinkComms[f] = TWO;
            secretNumberIterator = 1;
            break;
        }
      }
      else if(fourAvail && sixAvail){
        switch (secretNumberIterator) {
          case 0:
            secretNumberIterator = 3;
            break;
          case 3:
            secretNumberIterator = 5;
            break;
          case 5:
            secretNumberIterator = 3;
            break;
        }
      }
      else if(twoAvail && sixAvail){
        switch (secretNumberIterator) {
          case 0:
            secretNumberIterator = 1;
            break;
          case 1:
            secretNumberIterator = 5;
            break;
          case 5:
            secretNumberIterator = 1;
            break;
        }
      }
      else if(twoAvail){
        if(secretNumberIterator == 0) {
            secretNumberIterator = 1;
        }
      }
      else if(fourAvail){
        if(secretNumberIterator == 0) {
            secretNumberIterator = 3;
        }
      }
      else if(sixAvail){
        if(secretNumberIterator == 0) {
            secretNumberIterator = 5;
        }
      }      
    }

    if (buttonDoubleClicked()) {
      hideSecret = !hideSecret;
      FOREACH_FACE(f) {
        blinkComms[f] = TOGGLEHIDESECRET;
      }
      signalState = GO;
      skipSendingSecretNumber = true;
    }
    
    if (buttonMultiClicked() && buttonClickCount() == 3) {
      amTreasure = true;
      amTeamTreasure1 = false;
      amTeamTreasure3 = false;
      isFirstTeamTreasure = false;
    }


    FOREACH_FACE(f) {
      if (!isValueReceivedOnFaceExpired(f)) {//we have a neighbor
        if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {
          signalState = GO;

          if(getBlinkComms(getLastValueReceivedOnFace(f)) == TOGGLEHIDESECRET ){
            hideSecret = !hideSecret;
            skipSendingSecretNumber = true;
            FOREACH_FACE(f) {
              blinkComms[f] = TOGGLEHIDESECRET;
            }
          }
          if(getBlinkComms(getLastValueReceivedOnFace(f)) == TOGGLETEAM ){
            currentTeamColor = (currentTeamColor + 1) % 6;
            skipSendingSecretNumber = true;
            FOREACH_FACE(f) {
              blinkComms[f] = TOGGLETEAM;
            }
          }

          if(getBlinkComms(getLastValueReceivedOnFace(f)) == WINTHREE){
            checkWinnerTimer.set(CHECKING_DURATION);
            amTeamTreasure3 = true;
            teamColorTreasure = f;
          }
          if(getBlinkComms(getLastValueReceivedOnFace(f)) == WINONE){
            checkWinnerTimer.set(CHECKING_DURATION);
            amTeamTreasure1 = true;
            teamColorTreasure = f;
          }

          if(getBlinkComms(getLastValueReceivedOnFace(f)) == NOWINNER){
            switch (blinkComms[0]) {
              case TWO:
                twoAvail = false;
                break;
              case FOUR:
                fourAvail = false;
                break;
              case SIX:
                sixAvail = false;
                break;
            }
            waitingAfterLoss = true;
            checkWinnerTimer.set(CHECKING_DURATION);
          }
                    
          
          }

        }
      }


    if(!skipSendingSecretNumber){
      FOREACH_FACE(f) {
        switch (secretNumberIterator) {
          case 0:
            blinkComms[f] = ONE;
            break;
          case 1:
            blinkComms[f] = TWO;
            break;
    //      case 2:
    //        blinkComms[f] = THREE;
    //        break;
          case 3:
            blinkComms[f] = FOUR;
            break;
    //      case 4:
    //        blinkComms[f] = FIVE;
    //        break;
          case 5:
            blinkComms[f] = SIX;
            break;
        }
      }
    }
  }

  //TREASURE
  else {
    if(isFirstTeamTreasure && checkWinnerTimer.isExpired()){
      isFirstTeamTreasure = false;
    }
        
    if ( buttonSingleClicked()) {
      checkWinnerTimer.set(CHECKING_DURATION);
      checkForWinner();
    }
    
    if (buttonMultiClicked() && buttonClickCount() == 3) {
      amTreasure = false;
      amTeamTreasure1 = false;
      amTeamTreasure3 = false;
      hideSecret = false;
      twoAvail = true;
      fourAvail = true;
      sixAvail = true;
      isFirstTeamTreasure = true;
    }
  
//check for GO phase
    FOREACH_FACE(f) {
      if (!isValueReceivedOnFaceExpired(f)) {//we have a neighbor
        if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {
          signalState = GO;
  
          if(getBlinkComms(getLastValueReceivedOnFace(f)) == NOWINNER ){
            checkWinnerTimer.set(CHECKING_DURATION);
            checkForWinner();
          }
        }
      }
    }
  }
}

void goLoop() {
    signalState = RESOLVE;//I default to this at the start of the loop. Only if I see a problem does this not happen  

  //look for neighbors who have not heard the GO news
  FOREACH_FACE(f) {
    if (!isValueReceivedOnFaceExpired(f)) {//a neighbor!
      if (getSignalState(getLastValueReceivedOnFace(f)) == INERT) {//This neighbor doesn't know it's GO time. Stay in GO
        signalState = GO;
        
      }
    }
  }
}

void resolveLoop() {
    signalState = INERT;//I default to this at the start of the loop. Only if I see a problem does this not happen

  //look for neighbors who have not moved to RESOLVE
  FOREACH_FACE(f) {
    if (!isValueReceivedOnFaceExpired(f)) {//a neighbor!
      if (getSignalState(getLastValueReceivedOnFace(f)) == GO) {//This neighbor isn't in RESOLVE. Stay in RESOLVE
        signalState = RESOLVE;
      }
    }
  }
}


void checkForWinner(){
//  checkWinnerTimer.set(3000);

  //get numbers sent
  FOREACH_FACE(f) {
    treasureSecretsReceived[f] = 0;
    if (!isValueReceivedOnFaceExpired(f) ){//a neighbor
         byte newNumberText = getBlinkComms(getLastValueReceivedOnFace(f));
          switch (newNumberText) {
            case ONE:
              treasureSecretsReceived[f] = 1;
              break;
            case TWO:
              treasureSecretsReceived[f] = 2;
              break;
            case THREE:
              treasureSecretsReceived[f] = 3;
              break;
            case FOUR:
              treasureSecretsReceived[f] = 4;
              break;
            case FIVE:
              treasureSecretsReceived[f] = 5;
              break;
            case SIX:
              treasureSecretsReceived[f] = 6;
              break;
          }
//          //if NOT Bandit
//           if(getBlinkComms(getLastValueReceivedOnFace(f)) != ONE && getBlinkComms(getLastValueReceivedOnFace(f)) != TWO && 
//           getBlinkComms(getLastValueReceivedOnFace(f)) != THREE && getBlinkComms(getLastValueReceivedOnFace(f)) != FOUR &&
//           getBlinkComms(getLastValueReceivedOnFace(f)) != FIVE && getBlinkComms(getLastValueReceivedOnFace(f)) != SIX){
//              treasureSecretsReceived[f] = 0;
//           }
       }
  }
//
//        displayColor[0] = CYAN;
//        displayColor[1] = WHITE;
//        displayColor[2] = CYAN;
//        displayColor[3] = WHITE;
//        displayColor[4] = CYAN;
//        displayColor[5] = WHITE;


//Calculate if Winner
  if(treasureSecretsReceived[0] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[0] > treasureSecretsReceived[5]) {
    setDisplayColor(WHITE, YELLOW, OFF, OFF, OFF, YELLOW);
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure3){
      blinkComms[0] = WINONE;
      amTeamTreasure3 = false;
      amTeamTreasure2 = true;
    }
  }
  else if(treasureSecretsReceived[1] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[1] > treasureSecretsReceived[5]) {
    setDisplayColor(YELLOW, WHITE, YELLOW, OFF, OFF, OFF);
//    displayColor[0] = YELLOW;
//    displayColor[1] = WHITE;
//    displayColor[2] = YELLOW;
//    displayColor[3] = OFF;
//    displayColor[4] = OFF;
//    displayColor[5] = OFF;
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure3){
      blinkComms[0] = WINONE;
      amTeamTreasure3 = false;
      amTeamTreasure2 = true;
    }
  }
  else if(treasureSecretsReceived[2] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[2] > treasureSecretsReceived[5]) {
    setDisplayColor(OFF, YELLOW, WHITE, YELLOW, OFF, OFF);
//    displayColor[0] = OFF;
//    displayColor[1] = YELLOW;
//    displayColor[2] = WHITE;
//    displayColor[3] = YELLOW;
//    displayColor[4] = OFF;
//    displayColor[5] = OFF;
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure3){
      blinkComms[0] = WINONE;
      amTeamTreasure3 = false;
      amTeamTreasure2 = true;
    }
  }
  else if(treasureSecretsReceived[3] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[4] && 
  treasureSecretsReceived[3] > treasureSecretsReceived[5]) {
    setDisplayColor(OFF, OFF, YELLOW, WHITE, YELLOW, OFF);
//    displayColor[0] = OFF;
//    displayColor[1] = OFF;
//    displayColor[2] = YELLOW;
//    displayColor[3] = WHITE;
//    displayColor[4] = YELLOW;
//    displayColor[5] = OFF;
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure3){
      blinkComms[0] = WINONE;
      amTeamTreasure3 = false;
      amTeamTreasure2 = true;
    }
  }
  else if(treasureSecretsReceived[4] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[4] > treasureSecretsReceived[5]) {
    setDisplayColor(OFF, OFF, OFF, YELLOW, WHITE, YELLOW);
//    displayColor[0] = OFF;
//    displayColor[1] = OFF;
//    displayColor[2] = OFF;
//    displayColor[3] = YELLOW;
//    displayColor[4] = WHITE;
//    displayColor[5] = YELLOW;
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure3){
      blinkComms[0] = WINONE;
      amTeamTreasure3 = false;
      amTeamTreasure2 = true;
    }
  }
  else if(treasureSecretsReceived[5] > treasureSecretsReceived[0] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[1] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[2] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[3] && 
  treasureSecretsReceived[5] > treasureSecretsReceived[4]) {
    setDisplayColor(YELLOW, OFF, OFF, OFF, YELLOW, WHITE);
//    displayColor[0] = YELLOW;
//    displayColor[1] = OFF;
//    displayColor[2] = OFF;
//    displayColor[3] = OFF;
//    displayColor[4] = YELLOW;
//    displayColor[5] = WHITE;        
    if(amTreasure){
      blinkComms[0] = WINTHREE;
    }
    else if(amTeamTreasure3){
      blinkComms[0] = WINONE;
      amTeamTreasure3 = false;
      amTeamTreasure2 = true;
    }
  }
  signalState = GO;
}


byte setDisplayColor(Color f0, Color f1, Color f2, Color f3, Color f4, Color f5){
    displayColor[0] = f0;
    displayColor[1] = f1;
    displayColor[2] = f2;
    displayColor[3] = f3;
    displayColor[4] = f4;
    displayColor[5] = f5;
}

byte fullSparkle(Color white, Color blue){
  if( facetFaceRotationTimer.isExpired() ){
    facetFaceRotationTimer.set(100);
    baseFacetFace ++;
  }
  int whiteShine = random(5);
  int whiteShine2 = random(5)-3;
  int whiteShine3 = random(2);
  int blueShine = random(2);
  int purpShine = random(5);
  Color blue2 = makeColorRGB(84,204,255);
  Color purp = makeColorRGB(134,125,255);
  
    displayColor[baseFacetFace] = blue2;
    displayColor[baseFacetFace+1] = purp;
    displayColor[baseFacetFace+2] = blue2;
    displayColor[baseFacetFace+3] = purp;
    displayColor[baseFacetFace+4] = blue2;
    displayColor[baseFacetFace+5] = purp;
    displayColor[purpShine] = purp;    
    displayColor[whiteShine] = white;
    displayColor[blueShine] = blue;
    displayColor[(blueShine+2)%6] = blue;
    displayColor[whiteShine2] = white;
    displayColor[whiteShine3] = white;
}

//void resetTreasure(){
//  blinkComms[0] = NULLCOMM;
//  blinkComms[1] = NULLCOMM;
//  blinkComms[2] = NULLCOMM; 
//  blinkComms[3] = NULLCOMM;
//  blinkComms[4] = NULLCOMM; 
//  blinkComms[5] = NULLCOMM; 
////  needToSendWinSignal = false;
////  winningFace = 7;
//}



void displayFaceColor() {
  //default OFF to stop color lingering
  setColor(OFF);
    
  switch (signalState) {
    case INERT:
      FOREACH_FACE(f) {
        if (!amTreasure && !amTeamTreasure1 && !amTeamTreasure2 ^=&& !amTeamTreasure3 && f <= secretNumberIterator){
          setColorOnFace(dim(teamColors[currentTeamColor],clickDim),f);
        }

        //checking winner or delaying winner reveal bc checkWinnerTimer is running
        if(!checkWinnerTimer.isExpired()){
          if(isFirstTeamTreasure){
            //running timer and its my first time then act like a Bandit
            setColorOnFace(dim(teamColors[currentTeamColor],clickDim),f);
          }
          //running timer and not first time then circle spin ani
          if(amTreasure || amTeamTreasure1 || amTeamTreasure3){
            setColorOnFace(dim(WHITE,150),simpleIterateFace % 6);
            setColorOnFace(WHITE,(simpleIterateFace+1) % 6);
            setColorOnFace(dim(WHITE,150),(simpleIterateFace+2) % 6);
            setColorOnFace(OFF,(simpleIterateFace+3) % 6);
            setColorOnFace(OFF,(simpleIterateFace+4) % 6);
            setColorOnFace(OFF,(simpleIterateFace+5) % 6);
            if( simpleIterateFaceTimer.isExpired() ){
              simpleIterateFaceTimer.set(500);
              simpleIterateFace ++;
            }
          }
        }
        //checking winner timer is not running set baseline sparkle
        else if(!checkWinnerTimer.isExpired()){
          if ( amTreasure || amTeamTreasure1 || amTeamTreasure2 || amTeamTreasure3 ) {
            if( sparkleTimer.isExpired() ){
              sparkleTimer.set(10);
              fullSparkle(WHITE, CYAN);
            }
            setColorOnFace(displayColor[f],f);
          }
          //checking timer not running and Team Treasure so cover up sparkle with teamColor 
          if ( amTeamTreasure1 || amTeamTreasure2 || amTeamTreasure3 )
          {
            setColorOnFace(teamColors[currentTeamColor],teamColorTreasure % 6);
            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 1) % 6);
            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 5) % 6);
          }
          //checking timer not running and Team Treasure so cover up sparkle with OFFs
//          if(amTeamTreasure#){            
//            setColorOnFace(OFF,(teamColorTreasure + 2) % 6);
//            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 1) % 6);
//            setColorOnFace(teamColors[currentTeamColor],(teamColorTreasure + 5) % 6);
//            
//          }
          if(amTeamTreasure2){
            setColorOnFace(OFF,(teamColorTreasure + 4) % 6);
          }
          if(amTeamTreasure1){
            setColorOnFace(OFF,(teamColorTreasure + 2) % 6);
            setColorOnFace(OFF,(teamColorTreasure + 3) % 6);            
          }
        }
      }
      
      if (!amTreasure && !amTeamTreasure1 && !amTeamTreasure2 && !amTeamTreasure3 && hideSecret) {
        setColor(dim(teamColors[currentTeamColor],clickDim));
        setColorOnFace(OFF,simpleIterateFace % 6);
        setColorOnFace(OFF,(simpleIterateFace+3) % 6);
        if( simpleIterateFaceTimer.isExpired() ){
          simpleIterateFaceTimer.set(50);
          simpleIterateFace ++;
        }
      }
      break;
    case GO:
      setColor(MAGENTA);
      break;
    case RESOLVE:
      setColor(WHITE);
      break;
  }
}


byte getSignalState(byte data) {
    return ((data >> 4) & 3);//returns bits A & B
}

byte getBlinkComms(byte data) {
    return (data & 15);//returns bits C , D & E
}

